""" csv exploitation """
import csv
import ntpath as nt
import os
import re
from datetime import datetime
import pandas as pd

def find_line(target_word, fp):
    i = 0
    matches = []
    with open(fp, 'r') as f:
        for line in f:
            if re.search(target_word, line):
                matches.append(i)
                break
            i += 1
            if i > 300:
                return False
        return i

def find_line_bool(target_word, fp):
    with open(fp, 'r') as f:
        i = 0
        try:
            lines = f.readlines()
        except UnicodeDecodeError:
            return False
        while i < 200:
            for line in lines:
                if target_word in line:
                    return True
                i += 1
        return False

def get_size(file):
    total = 0
    for roots, dirs, files in os.walk(file):
        for f in files:
            fp = os.path.join(roots, f)
            total += os.path.getsize(fp)
    return total

def path_leaf(path):
    head, tail = nt.split(path)
    return tail

# file size
def file_size(path):
    stat = os.stat(path)
    byt = stat.st_size

    def convert_bytes(num):
        for x in ['bytes', 'KB', 'MB', 'GB', 'TB']:
            if num < 1024.0:
                return "%3.1f %s" % (num, x)
            num /= 1024.0

    return convert_bytes(byt)

# file tech
def find_tech(file):
    x = '%Protocol = '
    poss_tech = ['GSM', 'CDMA', 'EVDO', 'WCDMA', 'Layer 3']
    id = False
    for id in poss_tech:
        test_pbl = find_line_bool('Raw Position', file)  # raw position is found in PBL and not Dcode files
        if test_pbl:
            return 'PBL'
        test_decode = find_line_bool(x + id, file)
        if test_decode:
            return id
        test_L3 = find_line_bool('File Type = ' + id, file)
        if test_L3:
            return id
    return id

def find_type(file):        # TODO needs to be constantly updated when reading new file types
    if '.pbl' in file:
        return 'PBL'
    with open(file, 'r') as f:
        readme = csv.reader(f)
        for line in readme:
            # DEAKS TODO: remove debug
            # print('line = {0}'.format(line))
            if 'DCode' in line[0]:
                result = str('DCode')
                return result
            elif 'Layer 3' in line[0]:
                return str('L3')
            else:
                return False


def define_dcode(file):
    type = find_type(file)
    if not type:
        return False
    else:
        return True


def find_year(fp):              # only works for dcode files and L3
    kw = ' UTC Date'
    To_keyword = find_DCode_header(fp)
    df = pd.read_csv(fp, skiprows=To_keyword - 1, comment='%', error_bad_lines=False, sep=',', engine='python',
                     index_col=False)

    t = df[kw][1]
    t = datetime.strptime(t, ' %m/%d/%Y')
    date = str(t)[:4]
    return date



def find_DCode_header(file):
    i = 0
    with open(file, 'r') as f:
        while i < 300:
            for line in f:

                if not 'Latitude' in line:  # TODO: this was edited from "Point ID" to 'Latitude'
                    i += 1
                else:
                    return i
    return i

# the format of "decode_minandmax_latlong" should be used for Identifying any other file properties throughout the various Decode types
def decode_minandmax_latlong(fp):               # returns min and max values for latitude then longitude for the input file

    headers = ' Latitude', ' Longitude'         # these headers will most likely only work on decode files and L3 files
    To_keyword = find_DCode_header(fp)
    df = pd.read_csv(fp, skiprows=To_keyword - 1, comment='%', error_bad_lines=False, sep=',', engine='python',
                     index_col=False)           # 'comment='%'' eliminated a ton of errors as well as the 'engine='python''
    thresh = []
    for header in headers:
        g = df[header]
        t = g.drop_duplicates().iloc[
            0::10]                              # the 0::10 is important for avoiding TypeErrors for files with text in the columns toward the bottom
        _max = float(t.max())
        _min = float(t.min())
        thresh.append((_max, _min))
    return thresh                               # works for GSM, UMTS, CDMA, EVDO, and L3. Tested Files ages 2017 to 2019



